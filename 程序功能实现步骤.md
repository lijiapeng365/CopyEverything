# Windows 屏幕 OCR 小程序 - 后续功能实现步骤

**当前状态:**

*   项目基础结构已建立 (WPF, .NET)。
*   全局快捷键监听 (`HotkeyManager`) 已实现并集成。
*   屏幕选区覆盖窗口 (`SelectionOverlayWindow`) 已实现。
*   屏幕截图服务 (`ScreenCaptureService`) 已实现。
*   核心流程已打通：快捷键触发 -> 屏幕框选 -> 获取截图数据 (byte[]) -> 弹出占位提示框。
*   已解决编译过程中的各种问题。

**后续实现步骤:**

1.  **集成 OCR API 调用:**
    *   **目标:** 将获取到的截图数据发送给 OCR 服务并获取识别结果。
    *   **子任务:**
        *   **选择 OCR 服务:** 确定您要使用的具体 OCR API (如 OpenAI, 百度智能云, Google Cloud Vision 等)，或者先使用一个通用的 HTTP 调用框架。
        *   **添加 JSON 库:** 使用 `dotnet add package Newtonsoft.Json` 添加 NuGet 包，用于解析 API 返回的 JSON 数据。
        *   **创建 `OcrServiceCaller.cs`:** 在 `Services` 目录下创建此类。
            *   参考技术文档中的示例结构。
            *   实现一个异步方法，如 `public async Task<string?> RecognizeTextAsync(byte[] imageData, string apiKey, string endpointUrl, string? secretKey = null)`。
            *   使用 `HttpClient` 发送 POST 请求 (通常需要将 `imageData` 进行 Base64 编码)。
            *   根据所选服务的文档，正确设置请求头 (Authorization, Content-Type) 和请求体 (JSON 或 form-data)。
            *   **安全处理:** 从配置中读取 API Key/Secret，**严禁硬编码**。
            *   处理 HTTP 响应状态码 (`IsSuccessStatusCode`)。
            *   解析成功的 JSON 响应，提取文字结果。注意不同 API 返回的结构可能不同，需要适配。
            *   处理 API 返回的错误码和网络异常 (`try-catch`)，返回 `null` 或抛出特定异常。
        *   **修改 `App.xaml.cs`:**
            *   在 `HotkeyManager_HotkeyPressed` 方法中，获取到 `screenshotData` 后：
            *   创建 `OcrServiceCaller` 实例。
            *   调用 `RecognizeTextAsync` 方法 (使用 `await`)。
            *   在调用前后可以添加“识别中...”和“识别完成”的状态提示 (例如修改鼠标光标，或后续在结果窗口显示状态)。
            *   暂时将识别结果用 `System.Windows.MessageBox.Show()` 显示。

2.  **配置管理 (加载与使用):**
    *   **目标:** 从 `appsettings.json` 读取配置，替换硬编码的值。
    *   **子任务:**
        *   **添加配置库:** 使用 `dotnet add package Microsoft.Extensions.Configuration.Json` 和 `Microsoft.Extensions.Configuration.Binder` 添加 NuGet 包。
        *   **(可选) 创建配置模型类:** 在 `Models` 目录下创建与 `appsettings.json` 结构对应的 C# 类 (例如 `AppSettings`, `HotkeySettings`, `OcrSettings`)。
        *   **修改 `App.xaml.cs`:**
            *   在 `OnStartup` 或 `MainWindow_Loaded` 的早期阶段，使用 `ConfigurationBuilder` 加载 `appsettings.json`。
            *   将配置信息绑定到模型类实例或直接读取配置值。
            *   将 `HotkeyManager` 的注册逻辑中的硬编码快捷键 (`Keys.F1`, `ModifierKeys.Control | ModifierKeys.Alt`) 替换为从配置中读取的值。需要实现字符串到 `Keys` 和 `ModifierKeys` 枚举的转换逻辑。
            *   将创建 `OcrServiceCaller` 时所需的 API Key, Secret Key, Endpoint URL 替换为从配置中读取的值。

3.  **结果展示窗口:**
    *   **目标:** 创建一个专门的窗口来显示 OCR 识别结果，并提供复制功能。
    *   **子任务:**
        *   **创建 `ResultWindow.xaml` / `ResultWindow.xaml.cs`:** 在 `Views` 目录下创建。
        *   **设计界面 (`ResultWindow.xaml`):**
            *   使用无边框样式 (`WindowStyle="None"`, `AllowsTransparency="True"` 可能需要，但要小心渲染问题)。
            *   添加一个 `TextBlock` 或只读 `TextBox` 用于显示识别结果 (允许多行)。
            *   添加一个“复制”按钮。
            *   添加一个小的“关闭”按钮 (`X`)。
            *   (可选) 添加一个可拖动的区域 (例如一个小的标题栏或允许按住窗口背景拖动)。
        *   **实现逻辑 (`ResultWindow.xaml.cs`):**
            *   添加一个公共属性或方法，用于接收并显示识别到的文本。
            *   实现“复制”按钮的点击事件，使用 `System.Windows.Clipboard.SetText()` 将文本放入剪贴板。
            *   实现“关闭”按钮的点击事件 (`this.Close()`)。
            *   实现窗口拖动逻辑 (通常通过处理 `MouseLeftButtonDown` 事件)。
            *   实现窗口定位逻辑：在显示时，根据截图区域 (`selectedRegion`) 计算一个合适的位置 (如右侧或下方)。
            *   处理 OCR 未识别到文字或出错的情况 (显示提示信息)。
        *   **修改 `App.xaml.cs`:**
            *   在 `HotkeyManager_HotkeyPressed` 中，当 OCR 识别成功后，创建 `ResultWindow` 实例，传入识别结果，设置其位置，然后调用 `Show()` 或 `ShowDialog()` 显示。

4.  **系统托盘与后台运行:**
    *   **目标:** 让程序主要在后台运行，通过系统托盘图标交互。
    *   **子任务:**
        *   **添加托盘库:** 推荐使用 `Hardcodet.NotifyIcon.Wpf` NuGet 包。
        *   **修改 `App.xaml.cs`:**
            *   在 `MainWindow_Loaded` (或 `OnStartup` 调整后) 初始化 `TaskbarIcon` (来自 `Hardcodet.NotifyIcon.Wpf`)。
            *   设置托盘图标 (`IconSource`)。
            *   创建托盘右键菜单 (`ContextMenu`)，至少包含“退出”选项。可以添加“设置”等。
            *   实现“退出”菜单项的点击事件，调用 `Application.Current.Shutdown()`。
        *   **修改启动行为:**
            *   在 `App.xaml.cs` 的 `OnStartup` 中，可以选择不调用 `_mainWindow.Show()`，或者调用后立即 `_mainWindow.Hide()`，使主窗口默认不显示。
            *   确保 `MainWindow` 的 `ShowInTaskbar` 设置为 `False` (在 `MainWindow.xaml` 中)。
            *   可能需要调整 `HotkeyManager` 依赖 `MainWindow` 句柄的方式，如果 `MainWindow` 完全不创建或不显示，需要寻找替代方案来获取窗口句柄（例如创建一个隐藏的辅助窗口，或者如果托盘库本身提供了消息循环机制则利用它）。但目前 `HotkeyManager` 依赖 `MainWindow`，所以隐藏 `MainWindow` 比完全不创建更简单。

5.  **设置界面 (可选但推荐):**
    *   **目标:** 提供图形化界面让用户配置快捷键和 OCR API 凭证。
    *   **子任务:**
        *   **创建 `SettingsWindow.xaml` / `SettingsWindow.xaml.cs`:** 在 `Views` 目录下。
        *   **设计界面:** 添加用于选择快捷键组合的控件，输入 API Key/Secret/Endpoint 的文本框。添加“保存”和“取消”按钮。
        *   **实现逻辑:**
            *   窗口加载时，读取当前配置并显示。
            *   实现快捷键选择逻辑。
            *   实现“保存”按钮逻辑：验证用户输入，将新配置保存到 `appsettings.json` (需要研究如何安全地写入 JSON 配置，可能需要 `Microsoft.Extensions.Configuration.Json` 的写操作支持或手动读写)。**注意:** 保存 API Key 时考虑加密存储。保存后，需要通知正在运行的服务 (如 `HotkeyManager`) 重新加载配置。
            *   在系统托盘菜单中添加“设置”项，点击后打开 `SettingsWindow`。

6.  **错误处理与日志记录:**
    *   **目标:** 提高程序的健壮性和可维护性。
    *   **子任务:**
        *   使用更健壮的日志框架 (如 Serilog, NLog) 替代 `Debug.WriteLine` 和 `Console.WriteLine`，将日志输出到文件。
        *   在 `catch` 块中记录详细的异常信息 (`ex.ToString()`)。
        *   向用户提供更友好的错误提示，而不是直接显示异常信息。
        *   特别处理常见的 API 错误（如认证失败、额度用尽、网络问题），并给出相应提示。

7.  **部署:**
    *   **目标:** 将应用程序打包分发给用户。
    *   **子任务:**
        *   选择部署模式：推荐 **自包含 (Self-Contained)** 部署，这样用户无需额外安装 .NET 运行时。
        *   使用 `dotnet publish -c Release -r win-x64 --self-contained true` (或对应的架构) 命令发布。
        *   (可选) 使用 Inno Setup, NSIS 或 WiX Toolset 创建安装程序，处理快捷方式、开机启动项（如果提供）、配置文件放置等。


**建议顺序:**

建议按照 1 -> 2 -> 3 的顺序完成核心的 OCR 调用和结果展示。然后根据需要实现 4 (系统托盘)，之后再考虑 5 (设置界面) 和 6 (错误处理完善)，最后进行 7 (部署)。

---